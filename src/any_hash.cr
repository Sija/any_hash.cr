# Recursive wrapper for `Hash(K, V)`.
#
# Holds the given `V` values alone or recursively inside of a
# container type like `Array`, `Set` or another `Hash`.
#
# NOTE: Performs deep cast of container types:
# - `Array` → `Array(V)`
# - `Tuple` → `Array(V)`
# - `Set` → `Set(V)`
# - `NamedTuple` → `Hash(K, V)`
# - `Hash` → `Hash(K, V)`
# - `AnyHash` → `Hash(K, V)`
abstract class AnyHash(K, V)
  # Defines new klass *klass* inheriting from `AnyHash`
  # with given *key* keys and recursive *value* types.
  #
  # ```
  # AnyHash.define_new klass: :StringHash,
  #   key: String,
  #   value: String | Symbol
  #
  # StringHash::Key   # => String
  # StringHash::Value # => String | Symbol
  #
  # StringHash.new({"foo" => {:bar, "baz"}})
  # # => #<StringHash:0x100d5e180 @__hash__={"foo" => [:bar, "baz"]}>
  # ```
  #
  # See `AnyHash`.
  macro define_new(klass, key, value)
    # Namespace holding the types for `{{klass.id}}`.
    #
    # NOTE: Module auto-generated by `AnyHash.define_new`.
    module {{klass.id}}Types
      alias Key = {{key.id}}
      alias ValueType = {{value.id}}
      alias Value = ValueType | Array(Value) | Set(Value) | Hash(Key, Value)
      alias Instance = ::AnyHash(Key, Value)
    end

    # Wrapper for `Hash(K, V)` with `{{key.id}}` keys and
    # recursive `{{value.id}})` values.
    #
    # NOTE: Class auto-generated by `AnyHash.define_new`.
    #
    # See `AnyHash`.
    class {{klass.id}} < {{klass.id}}Types::Instance
      include {{klass.id}}Types
    end
  end

  # Deep casts *value* to the `V` type.
  def self.deep_cast_value(value)
    # FIXME: ouch, `NamedTuple#to_h` internally uses `#clone`
    # which `Time` doesn't support...
    case value
    when Array(V)      then value
    when Array         then value.map { |v| deep_cast_value(v).as(V) }
    when Set(V)        then value
    when Set           then value.map { |v| deep_cast_value(v).as(V) }.to_set
    when Tuple         then deep_cast_value(value.to_a)
    when NamedTuple    then deep_cast_value(value.to_a.to_h)
    when AnyHash(K, V) then value.to_h
    when AnyHash       then deep_cast_value(value.to_h)
    when Hash(K, V)    then value
    when Hash
      value.each_with_object({} of K => V) do |(k, v), memo|
        memo[k] = deep_cast_value(v)
      end
    else
      value.as(V)
    end
  end

  # :nodoc:
  protected def self.internal_deep_merge!(hash, *values, **options, &block)
    values += {options}
    values.each do |other_hash|
      other_hash.try &.each do |other_key, other_value|
        other_value = yield(other_key, other_value) || other_value
        other_value = deep_cast_value(other_value)

        original_value = hash[other_key]?
        if original_value.is_a?(Hash) && other_value.is_a?(Hash)
          deep_merge!(original_value, other_value)
        else
          hash[other_key] = other_value
        end
      end
    end
    hash
  end

  # :nodoc:
  def self.deep_merge!(hash, *values, **options, &block)
    internal_deep_merge!(hash, *values, **options) do |other_key, other_value|
      if hash.has_key?(other_key)
        yield other_key, hash[other_key], other_value
      end
    end
  end

  # :nodoc:
  def self.deep_merge!(hash, *values, **options)
    internal_deep_merge!(hash, *values, **options) { }
  end

  @__hash__ : Hash(K, V)
  forward_missing_to @__hash__

  # See `Hash#==`.
  delegate :==, :===, to: @__hash__

  # ditto
  def_equals @__hash__

  # ditto
  def ==(other : NamedTuple)
    self == self.class.deep_cast_value(other)
  end

  # include Enumerable({K, V})
  # include Iterable({K, V})

  # :nodoc:
  private macro chain_hash_methods(method_names)
    {% for method in method_names %}
      # NOTE: Wrapper for `Hash#{{method.id}}` returning `self`.
      def {{method.id}}(*args, **kwargs)
        @__hash__.{{method.id}}(*args, **kwargs)
        self
      end

      # NOTE: Wrapper for block version of `Hash#{{method.id}}` returning `self`.
      def {{method.id}}(*args, **kwargs, &block)
        @__hash__.{{method.id}}(*args, **kwargs) { |*blargs| yield *blargs }
        self
      end
    {% end %}
  end

  chain_hash_methods %w(delete_if reject! select! compact! clear)

  # Initializes `AnyHash` with the given *hash* object.
  #
  # NOTE: `AnyHash | Hash` objects are passed by reference.
  def initialize(hash = nil)
    if hash
      @__hash__ = self.class.deep_cast_value(hash).as(Hash(K, V))
    else
      @__hash__ = {} of K => V
    end
  end

  # See `Hash#[]=`.
  def []=(key, value)
    @__hash__[key] = self.class.deep_cast_value(value)
  end

  # Extracts the nested value specified by the sequence of *keys* objects
  # by calling `#[]?` at each step, returns `nil`
  # if any intermediate step is `nil`.
  def dig?(*keys)
    keys.reduce(@__hash__) do |memo, key|
      memo.as?(Hash(K, V)).try(&.[]?(key)) || break
    end
  end

  # Extracts the nested value specified by the sequence of *keys* objects
  # by calling `#[]` at each step, raises
  # if any intermediate step is `nil`.
  def dig(*keys)
    keys.reduce(@__hash__) do |memo, key|
      memo.as(Hash)[key]
    end
  end

  # Performs deep merge of `self` with given other *values*
  # and returns copy of `self`.
  #
  # See `Hash#merge`.
  def merge(*values, **options)
    dup.merge!(*values, **options)
  end

  # ditto
  def merge(*values, **options, &block)
    dup.merge!(*values, **options) { |*args| yield *args }
  end

  # Performs deep merge of `self` with given other *values* and returns `self`.
  #
  # See `Hash#merge!`.
  def merge!(*values, **options)
    self.class.deep_merge!(@__hash__, *values, **options)
    self
  end

  # ditto
  def merge!(*values, **options, &block)
    self.class.deep_merge!(@__hash__, *values, **options) { |*args| yield *args }
    self
  end

  # Clears and merges `self` with given *other*.
  # Returns `self`.
  def replace(other)
    clear
    merge! other
  end
end

require "./any_hash/*"
