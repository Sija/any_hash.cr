# Recursive wrapper for `Hash(K, V)`.
#
# Holds the given `V` values alone or recursively inside of a
# container type like `Array`, `Set` or another `Hash`.
#
# NOTE: Performs deep cast of container types:
# - `Array` → `Array(V)`
# - `Tuple` → `Array(V)`
# - `Set` → `Set(V)`
# - `NamedTuple` → `Hash(K, V)`
# - `Hash` → `Hash(K, V)`
# - `AnyHash` → `Hash(K, V)`
abstract class AnyHash(K, V)
  include Enumerable({K, V})
  include Iterable({K, V})

  # Defines new klass *klass* inheriting from `AnyHash`
  # with given *key* keys and recursive *value* types.
  #
  # ```
  # AnyHash.define_new klass: :StringHash,
  #   key: String,
  #   value: String | Symbol
  #
  # StringHash::Key   # => String
  # StringHash::Value # => String | Symbol
  #
  # StringHash.new({"foo" => {:bar, "baz"}})
  # # => #<StringHash:0x100d5e180 @__hash__={"foo" => [:bar, "baz"]}>
  # ```
  #
  # See `AnyHash`.
  macro define_new(klass, key, value)
    # Namespace holding the types for `{{klass.id}}`.
    #
    # NOTE: Module auto-generated by `AnyHash.define_new`.
    module {{klass.id}}Types
      alias Key = {{key.id}}
      alias ValueType = {{value.id}}
      alias Value = ValueType | Array(Value) | Set(Value) | Hash(Key, Value)
      alias Instance = ::AnyHash(Key, Value)
    end

    # Wrapper for `Hash(K, V)` with `{{key.id}}` keys and
    # recursive `{{value.id}})` values.
    #
    # NOTE: Class auto-generated by `AnyHash.define_new`.
    #
    # See `AnyHash`.
    class {{klass.id}} < {{klass.id}}Types::Instance
      include {{klass.id}}Types
    end
  end

  # Deep casts *value* to the `V` type.
  #
  # ameba:disable Metrics/CyclomaticComplexity
  def self.deep_cast_value(value)
    case value
    when Array(V)      then value
    when Array         then value.map { |v| deep_cast_value(v).as(V) }
    when Set(V)        then value
    when Set           then value.map { |v| deep_cast_value(v).as(V) }.to_set
    when Tuple         then deep_cast_value(value.to_a)
    when NamedTuple    then deep_cast_value(value.to_h)
    when AnyHash(K, V) then value.to_h
    when AnyHash       then deep_cast_value(value.to_h)
    when Hash(K, V)    then value
    when Hash
      value.each_with_object({} of K => V) do |(k, v), memo|
        memo[k] = deep_cast_value(v)
      end
    else
      value.as(V)
    end
  end

  # :nodoc:
  protected def self.internal_deep_merge!(hash, *values, **options, &block)
    values += {options}
    values.each do |other_hash|
      other_hash.try &.each do |other_key, other_value|
        other_value = yield(other_key, other_value) || other_value
        other_value = deep_cast_value(other_value)

        original_value = hash[other_key]?
        if original_value.is_a?(Hash) && other_value.is_a?(Hash)
          other_value = deep_merge!(original_value.dup, other_value)
        end
        hash[other_key] = other_value
      end
    end
    hash
  end

  # :nodoc:
  def self.deep_merge!(hash, *values, **options, &block)
    internal_deep_merge!(hash, *values, **options) do |other_key, other_value|
      if hash.has_key?(other_key)
        yield other_key, hash[other_key], other_value
      end
    end
  end

  # :nodoc:
  def self.deep_merge!(hash, *values, **options)
    internal_deep_merge!(hash, *values, **options) { }
  end

  @__hash__ : Hash(K, V)

  # List of methods delegated to the underlying `Hash` returning `self`.
  CHAINED_HASH_METHODS = %w(delete_if reject! select! compact! clear)

  macro method_missing(call)
    {% if CHAINED_HASH_METHODS.includes?(call.name.stringify) %}
      @__hash__.{{call}}
      self
    {% else %}
      @__hash__.{{call}}
    {% end %}
  end

  # See `Hash#to_h`.
  delegate :to_h, to: @__hash__

  # See `Hash#==`.
  delegate :==, :===, to: @__hash__

  # See `Hash#each`.
  delegate :each, to: @__hash__

  # ditto
  def_equals @__hash__

  # ditto
  def ==(other : NamedTuple)
    self == self.class.deep_cast_value(other)
  end

  # Initializes `AnyHash` with the given *hash* object.
  #
  # NOTE: `AnyHash | Hash` objects are passed by reference.
  def initialize(hash = nil)
    if hash
      @__hash__ = self.class.deep_cast_value(hash).as(Hash(K, V))
    else
      @__hash__ = {} of K => V
    end
  end

  # Returns a new `AnyHash`, with a shallow copy of the underlying `Hash`.
  #
  # Use `#clone` if you want a deep copy.
  def dup
    self.class.new @__hash__.dup
  end

  # Returns a new `AnyHash`, with a deep copy of the underlying `Hash`.
  #
  # Use `#dup` if you want a shallow copy.
  def clone
    self.class.new.merge! @__hash__
  end

  # See `Hash#[]=`.
  def []=(*args)
    args = args.to_a
    # Split *args* into the *path* to nested hash where, under the *key*
    # lies the *value* we overwrite.
    path, key, value = args[0...-2], args[args.size - 2], args[args.size - 1]
    # dig 'em hash
    dig(path).as(Hash(K, V))[key.as(K)] = self.class.deep_cast_value(value)
  end

  # See `Hash#[]=`.
  def []=(key, value)
    @__hash__[key] = self.class.deep_cast_value(value)
  end

  # See `#dig?`.
  def []?(*keys)
    dig? keys
  end

  # See `#dig`.
  def [](*keys)
    dig keys
  end

  # Extracts the nested value specified by the sequence of *keys* objects
  # by calling `#[]?` at each step, returns `nil`
  # if any intermediate step is `nil`.
  def dig?(keys : Enumerable)
    keys.reduce(@__hash__) do |memo, key|
      memo.as?(Hash(K, V)).try(&.[]?(key)) || break
    end
  end

  # ditto
  def dig?(*keys)
    dig?(keys)
  end

  # Extracts the nested value specified by the sequence of *keys* objects
  # by calling `#[]` at each step, raises
  # if any intermediate step is `nil`.
  def dig(keys : Enumerable)
    keys.reduce(@__hash__) do |memo, key|
      memo.as(Hash(K, V))[key]
    end
  end

  # ditto
  def dig(*keys)
    dig(keys)
  end

  # Performs deep merge of `self` with given other *values*
  # and returns copy of `self`.
  #
  # See `Hash#merge`.
  def merge(*values, **options)
    dup.merge!(*values, **options)
  end

  # ditto
  def merge(*values, **options, &block)
    dup.merge!(*values, **options) { |*args| yield *args }
  end

  # Destructive version of `#merge`.
  def merge!(*values, **options)
    self.class.deep_merge!(@__hash__, *values, **options)
    self
  end

  # ditto
  def merge!(*values, **options, &block)
    self.class.deep_merge!(@__hash__, *values, **options) { |*args| yield *args }
    self
  end

  # Merges the caller into *other*. For example,
  #
  # ```
  # options = options.reverse_merge(size: 25, velocity: 10)
  # ```
  #
  # is equivalent to
  #
  # ```
  # options = { size: 25, velocity: 10 }.merge(options)
  # ```
  #
  # This is particularly useful for initializing an options hash with default values.
  def reverse_merge(other = nil, *values, **options)
    dup.reverse_merge!(other, *values, **options)
  end

  # ditto
  def reverse_merge(other = nil, *values, **options, &block)
    dup.reverse_merge!(other, *values, **options) { |*args| yield *args }
  end

  # Destructive version of `#reverse_merge`.
  def reverse_merge!(other = nil, *values, **options)
    values = {self, other} + values + {options}
    hash = self.class.new.merge!(*values.reverse)
    replace(hash)
  end

  # ditto
  def reverse_merge!(other = nil, *values, **options, &block)
    values = {self, other} + values + {options}
    hash = self.class.new.merge!(*values.reverse) { |*args| yield *args }
    replace(hash)
  end

  # Replaces underlying `Hash` with given *other*.
  #
  # Returns `self`.
  def replace(other)
    case other
    when AnyHash(K, V) then @__hash__ = other.to_h
    when Hash(K, V)    then @__hash__ = other
    else
      clear
      merge!(other)
    end
    self
  end
end

require "./any_hash/*"
